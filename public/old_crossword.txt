COMPRESS
INORE
THSE
FREEEEE
LOFT
SCREEN
ELECT
VOTS
TAKE
CRYS

.. .. .. 1. .. .. .. .. .. .. ..
.. 2. 2. 12 2. 2. .. .. 3. .. ..
.. .. .. 1. .. .. .. .. 3. .. ..
.. .. .. 1. .. .. .. .. 3. .. ..
.. .. 4. 14 4. 4. 4. 4. 34 .. ..
.. .. .. 1. .. .. .. .. .. .. ..
.. 5. .. 16 6. 6. 6. 67 6. .. ..
8. 58 8. 18 .. .. .. 7. .. .. ..
.. 5. .. .. .. .. .. 7. .. .. ..
.. 59 9. 9. 9. .. .. 7A A. A. A.

class Cell {

  ids: Set<number>;
  letter: string;

  row: number;
  col: number;

  constructor(row: number, col: number, ids: Set<number>) {
    this.ids = ids;
    this.letter = '';
    
    this.row = row;
    this.col = col;
  }
}

// isLeftOf(otherCell: Cell): boolean {
  //   return this.row == otherCell.row && this.col - otherCell.col == -1
  // }

  // isRightOf(otherCell: Cell): boolean {
  //   return this.row == otherCell.row && this.col - otherCell.col == 1
  // }

  // isTopOf(otherCell: Cell): boolean {
  //   return this.col == otherCell.col && this.row - otherCell.row == 1
  // }

  // isBottomOf(otherCell: Cell): boolean {
  //   return this.col == otherCell.col && this.row - otherCell.row == -1
  // }

  // isSame

//   constructor(row: number, col: number, ids: Set<number>) {
//     this.row = row;
//     this.col = col;
//     this.ids = ids;
//   }
// }

// class Crossword {

//   numRows: number;
//   numCols: number;
//   cells: Set<Cell>;

//   constructor(inputFilePath: string) {

//     let lines: Array<string> = [];

//     let cells: Set<Cell> = []

//     let numRows = 0;
//     let numCols = 0;

//     fetch(inputFilePath)
//       .then((ret: Response) => ret.text())
//       .then((text: string) => {

//         lines = text.split('\r\n');
        
//       }
//     );

//     console.log(lines);

//     let words: Array<string> = []

//     let i = 0;

//     for (i = i; lines[i] != ''; i++)
//       words.push(lines[i]);

//     numCols = lines[i].length;

//     let row: number = 0;
//     for (i = i; i < lines.length; i++, row++) {
//       let cellsStrs: Array<string> = lines[i].split(' ');

//       for (let col = 0; col < cellsStrs.length; col++) {
//         let ids: Set<number> = this.getCellIDsFromString(cellsStrs[col]);

//         if (ids.size > 0)
//           cells.add(new Cell(row, col, ids));
//       }
//     }

//     numRows = row;

//     this.numRows = numRows
//     this.numCols = numCols;
//     this.cells = cells;
//   }

//   getCellIDsFromString(str: string): Set<number> {

//     let ids: Set<number> = new Set();
//     for (const char of str) {
//       if (char == '.')
//         continue;

//       let id = 0;
//       if (char.match('[A-Z]'))
//         id = char.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
//       else
//         id = parseInt(char);

//       ids.add(id);
//     }

//     return ids;
//   }



//   getCellElements(): Array<JSX.Element> {
//     let elements: Array<JSX.Element> = []

//     for (let i = 0; i < this.cells.length; i++) {
//       let classNames = `cell c${{i}}`
//       elements.push(<div className={classNames}></div>)
//     }
//   }

//   cellIsStart(cell: Cell): boolean {
    
//     for (const otherCell of this.cells) {
//       if (cell.isRightOf(otherCell) && cell.)
//     }
//   }


    // for (const cellPos of cellPoses) {

    //   let element: HTMLElement | null = document.getElementById(`c${cellPos.toString()}`);

    //   if (element != null) {

    //     let somethingAbove: boolean = false;
    //     let somethingLeft: boolean = false;

    //     for (const otherCellPos of cellPoses) {
    //       let offset: CellPos = cellPos.getOffset(otherCellPos);
    //       if (offset.isSameAs(new CellPos(1, 0)))
    //         somethingAbove = true;
    //       if (offset.isSameAs(new CellPos(0, 1)))
    //         somethingLeft = true;
    //     }

    //     if (!somethingAbove)
    //       element.style.borderTopWidth = '4px';

    //     if (!somethingLeft)
    //       element.style.borderLeftWidth = '4px';
    //   }
    // }